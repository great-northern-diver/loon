<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="title">
Loon: An Interactive Statistical Visualization Toolkit
</div>
<div id="nav">
<ul>
  <li id="home"><a href="index.html">Home</a></li>
  <li id="beta"><a href="beta.html">Beta</a></li>
  <li id="ui"><a href="UI.html">UI</a></li>
  <li id="learn"><a href="learn_R_intro.html">Learn</a></li>
  <li id="gallery"><a href="gallery.html">Gallery</a></li>
  <!-- <li id="videos"><a href="videos.html">Videos</a></li>  -->
  <!-- <li id="commands"><a href="commands.html">Commands</a></li>  -->
  <!-- <li id="manual"><a href="manual_Tcl.html">Manual</a></li>  -->
  <!-- <li id="develop"><a href="develop_setup.html">Develop</a></li> -->
</ul>

<ul>
  <li id="learn_R"><a href="learn_R_intro.html">R</a></li>
  <li id="learn_Tcl"><a href="learn_Tcl_intro.html">Tcl</a></li>
<!--  <li id="learn_Python"><a href="learn_Python_intro.html">Python</a></li> --> 
</ul> 
  
<script>
document.getElementById("learn").className += " selected";

var setLearnUrl = function(section) {
    var languages = ["R", "Tcl"]; 
    for (i in  languages) {
        document.getElementById("learn_" + languages[i]).
        firstChild.href = "learn_"+languages[i]+ "_" + section + ".html";
    }
}

</script>

<ul>
  <li id="learn_intro"><a href="learn_Tcl_intro.html">intro</a></li>
  <li id="learn_Tcl_Tk"><a href="learn_Tcl_Tk.html">tk</a></li>
  <li id="learn_states"><a href="learn_Tcl_states.html">states</a></li>
  <li id="learn_linking"><a href="learn_Tcl_linking.html">linking</a></li>
  <li id="learn_layer"><a href="learn_Tcl_layer.html">layer</a></li>
  <li id="learn_bind"><a href="learn_Tcl_bind.html">bind</a></li>
  <li id="learn_displays"><a href="learn_Tcl_display_hist.html">displays</a></li>
  <li id="learn_widgets"><a href="learn_Tcl_layout.html">layout</a></li>
</ul>

<script>
document.getElementById("learn_Tcl").className += " selected";
var language = "Tcl";
</script>

<ul>
  <li id="learn_display_hist"><a id="learn_display_hist_a" href="">histogram</a></li>
  <li id="learn_display_plot"><a id="learn_display_plot_a" href="">scatterplot</a></li>
  <li id="learn_display_serialaxes"><a id="learn_display_serialaxes_a" href="">serialaxes</a></li>
  <li id="learn_display_pairs"><a id="learn_display_pairs_a" href="">scatterplot matrix</a></li>
  <li id="learn_display_graph"><a id="learn_display_graph_a" href="">graph</a></li>
  <li id="learn_display_inspectors"><a id="learn_display_inspectors_a" href="">inspectors</a></li>
</ul> 


<script>
document.getElementById("learn_displays").className += " selected";
var displays = ["hist", "plot", "serialaxes", "pairs", "graph", "inspectors"];


displays.forEach(function(display) {
  document.getElementById("learn_display_" + display  + "_a").href 
    = "learn_" + language + "_display_" + display + ".html";
});
</script>
</div>
<div id="TOC">
<ul>
<li><a href="#graph">Graph</a></li>
<li><a href="#good-to-know">Good To Know</a></li>
<li><a href="#navigation-graphs">Navigation Graphs</a><ul>
<li><a href="#navigators">Navigators</a></li>
<li><a href="#interaction-with-the-navigators">Interaction with the Navigators</a></li>
<li><a href="#navigator-state-bindings">Navigator State Bindings</a><ul>
<li><a href="#substitution">Substitution</a></li>
</ul></li>
<li><a href="#contexts">Contexts</a><ul>
<li><a href="#geodesic-2d">Geodesic 2d</a></li>
<li><a href="#context-2d">Context 2d</a></li>
</ul></li>
<li><a href="#graph-switch-widget">Graph Switch Widget</a><ul>
<li><a href="#working-with-the-graphswitch">Working with the Graphswitch</a></li>
</ul></li>
</ul></li>
<li><a href="#graph-utilities">Graph Utilities</a></li>
</ul>
</div>
<script>
window.onload = function() {
    document.getElementById("learn_display_graph").className += " selected";
    setLearnUrl("display_graph");
}
</script>
<div class="figure">
<img src="images/display_graph.png" title="loon graph display" alt="" />

</div>
<pre><code>set nodes [list A B C D E]
set G [completegraph $nodes]
set LG [linegraph {*}$G]

set g [graph -nodes [lindex $LG 0] -from [lindex $LG 1]\
  -to [lindex $LG 2] -isDirected [lindex $LG 3]]

$g navigator add </code></pre>
<h1 id="graph">Graph</h1>
<ul>
<li><p><code>loon</code>'s Graphs are defined by a list of node names, the from-to list of node names that define the edges and a Boolean value whether the graph is directed or not. This translates into the states <code>nodes</code>, <code>from</code>, <code>to</code>, and <code>isDirected</code>.</p></li>
<li><p>Get the state names with</p>
<pre><code>set states [$g info states]
dict keys $states</code></pre></li>
<li><p>Query a state, say <code>background</code>, as follows</p>
<pre><code>$g cget -background</code></pre></li>
<li><p>Change a state, say again <code>background</code>, <code>foreground</code>, and <code>colorEdge</code>, as follows</p>
<pre><code>$g configure -background gray20 -foreground gray90 -colorEdge red</code></pre></li>
<li><p>When creating a graph display you may specify any state at plot creation</p>
<pre><code>set nodes [list a b c]
set G [completegraph $nodes]
set LG [linegraph {*}$G]
set g1 [graph -nodes [lindex $LG 0] -from [lindex $LG 1]\
    -to [lindex $LG 2] -isDirected [lindex $LG 3]] -colorEdge red</code></pre></li>
<li><p>details on a state, say <code>background</code>, is easily had with</p>
<pre><code>set states [$g info states]
dict get $states background</code></pre>
<p>and a particular field</p>
<pre><code>dict get $states background description</code></pre></li>
</ul>
<h1 id="good-to-know">Good To Know</h1>
<ul>
<li>The graph is and scatterplot display are closely related and share most of the scatterplot states.
<div class="todo">
<pre><code>* This has some undesirable side effects such as that the
states `itemlabel` and `showItemlabels` are actually for
nodes...
* Also the tags are not correct... (i.e. point vs. node)</code></pre>
</div></li>
<li><p>The graph has <code>n</code> dimensional states that are associated to nodes and <code>p</code> dimensional states that are associated with edges. To query which states are <code>p</code> dimensional use</p>
<pre><code>set states [$g info states]
set pstates [dict filter $states script {k v} {
    set dim [dict get $v dimension]
    expr {$dim eq &quot;p&quot;}
}]
dict keys $pstates  </code></pre></li>
<li><p>To change the layout of the graph use a graph layout algorithm and set the <code>x</code> and <code>y</code> states of the <code>loon</code> graph accordingly. <code>loon</code> supports straight lines for edges only.</p></li>
</ul>
<h1 id="navigation-graphs">Navigation Graphs</h1>
<p>To turn a graph into a navigation graph you need to add one or more navigators. Navigators have their own set of states such as <code>from</code>, <code>to</code> and <code>proportion</code>, and you can create state bindings for the navigator that call a function when a navigator changes its position on the graph. States and state bindings for navigators provide the facility to implement any graph semantic. However, certain graph semantics (e.g. the default semantic with 2d projection along a geodesic path between spaces) involve lots of logic and control over plots, and hence it makes sense to en encapsulate them. We do this by providing <em>contexts</em>. A context is added to a navigator and will do a specific task if the navigator's position on the graph changes.</p>
<h2 id="navigators">Navigators</h2>
<p>We use the example at the beginning of this section:</p>
<pre><code>set nodes [list A B C D E]
set G [completegraph $nodes]
set LG [linegraph {*}$G]

set g [graph -nodes [lindex $LG 0] -from [lindex $LG 1]\
  -to [lindex $LG 2] -isDirected [lindex $LG 3]]</code></pre>
<p>The following code ads a navigator to the graph <code>g</code></p>
<pre><code>set nav [$g navigator add -color orange]</code></pre>
<div class="figure">
<img src="images/display_graph_navigator1.png" title="loon graph display" alt="" />

</div>
<p>The navigator with the id stored in the <code>nav</code> has its own states that can be listed as follows</p>
<pre><code>set nstates [$g navigator use $nav info states]
dict keys $nstates</code></pre>
<p>The position of the navigator on the graph is completely defined by the states <code>from</code>, <code>to</code>, and <code>proportion</code>. The states <code>from</code> and <code>to</code> hold lists of node names of the graph. The <code>proportion</code> state is a number between and including <code>0</code> and <code>1</code> and defines the how far the navigator is between the last element of <code>from</code> and the first element of <code>to</code>. The <code>to</code> state can also be an empty list if there is no further node to go to. Hence, the concatenation of <code>from</code> and <code>to</code> define a path on the graph.</p>
<h2 id="interaction-with-the-navigators">Interaction with the Navigators</h2>
<p>The position of the navigator on the graph can be controlled programatically as follows:</p>
<pre><code>$g navigator use $nav configure\
    -from {A:B B:C C:D A:D} -to {D:E B:E}\
    -proportion 0.2</code></pre>
<div class="figure">
<img src="images/display_graph_navigator2.png" title="navigator path" alt="" />

</div>
<p>The elements related to the navigator you see on the plot above are the</p>
<ul>
<li><strong>Navigator:</strong> wich is <code>proprtion</code> between the last node in <code>from</code> and the first node in <code>to</code>. If <code>to</code> is empty, then the navigator sits on the last node of <code>from</code>.</li>
<li><strong>From Path:</strong> highlighted with a bold line with the same color as the navigator show path stored in <code>from</code> and the <code>proportion</code> that has been traversed on the current edge.</li>
<li><strong>To Path:</strong> highlighted with a thinner line as the from path and with the same color as the navigator.</li>
<li><strong>Path End:</strong> which looks like the navigator and is located on the last node in <code>to</code>.</li>
</ul>
<p>The graph display supports direct interaction with the navigator and navigator path using the mouse and keyboard. To move the navigator with the mouse you must first click on it to select it which will set the <code>activeNavigator</code> graph state to the navigator id and causes the navigator to be highlighted with the navigator outline in the selection color.</p>
<div class="figure">
<img src="images/display_graph_navigator_select.png" title="navigator selected" alt="" />

</div>
<p>In this state the following interactions are possible</p>
<ul>
<li>Drag the navigator along the path.</li>
<li>If arriving at last node on the path you may extend the path by dragging the navigator towards a new connected node. Note that
<ul>
<li>the gray circle is the decision boundary to select an adjoining edge.</li>
<li>all the adjoining nodes are highlighted <img src="images/display_graph_navigator_addtopath.png" title="add to path" alt="" /></li>
</ul></li>
<li>Use the scroll wheel to move the navigator along the path. Pay attention to the <code>scrollProportionIncrement</code> state of the navigator.</li>
<li>Move the navigator using animation by control double click on a node on the path.</li>
<li>Extend the path by pressing the shift key while selecting adjoining nodes to the path end.</li>
<li>Delete the path and move the navigator to a new node by clicking on a new node.</li>
</ul>
<p>Note that the selection of a navigator, the highlighting of the adjacent nodes, and the edge selection circle are mouse interaction states and have no equivalent display states. That is, they are all transient and are undone as soon as the Shift and or Mouse press gets released.</p>
<p>The animation of the navigator can also be done programatically with any of the following commands</p>
<pre><code>$g navigator use $nav walk forward
$g navigator use $nav walk backward
$g navigator use $nav walk forward C:D
$g navigator use $nav walk backward B:C
$g navigator use $nav walk path {D:E B:E B:D A:D}</code></pre>
<ul>
<li>Note the two navigator states <code>animationPause</code> and <code>animationProportionIncrement</code> to control the animation speed.</li>
<li>You can stop the animation when clicking somewhere, or by scrolling.</li>
</ul>
<h2 id="navigator-state-bindings">Navigator State Bindings</h2>
<p>Navigators support <a
href="learn_Tcl_bind.html#state-bindings">state bindings.</a> You can use state bindings to implement your custom navigation graph semantic.</p>
<p>We use the following graph and navigator for our example:</p>
<pre><code>set nodes [list A B C D E]
set G [completegraph $nodes]
set LG [linegraph {*}$G]

set g [graph -nodes [lindex $LG 0] -from [lindex $LG 1]\
  -to [lindex $LG 2] -isDirected [lindex $LG 3]]

set nav [$g navigator add]</code></pre>
<p>To add a state binding use</p>
<pre><code>proc my_semantic {widget navigator} {
    set p [$widget navigator use $navigator cget -proportion]
    set nf [lindex [$widget navigator use $navigator cget -from] end]
    set nt [lindex [$widget navigator use $navigator cget -to] 0]
    puts [format &quot;do stuff: %s, %s, %s-%.2f-%s&quot; $widget $navigator $nf $p $nt]
}

$g navigator use $nav bind state add {from to proportion}\
    {my_semantic %W %nav}</code></pre>
<h3 id="substitution">Substitution</h3>
<p>The current substitutions for navigator state bindings are</p>
<table>
<thead>
<tr class="header">
<th align="center">argument name</th>
<th align="left">substituted value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>%W</code></td>
<td align="left">widget path name</td>
</tr>
<tr class="even">
<td align="center"><code>%nav</code></td>
<td align="left">navigator id</td>
</tr>
<tr class="odd">
<td align="center"><code>%e</code></td>
<td align="left">events (states changed)</td>
</tr>
<tr class="even">
<td align="center"><code>%b</code></td>
<td align="left">binding id</td>
</tr>
<tr class="odd">
<td align="center"><code>%O</code></td>
<td align="left">canvas path, useful for debugging</td>
</tr>
</tbody>
</table>
<h2 id="contexts">Contexts</h2>
<p>Contexts implement standard graph semantics. Common to all contexts is that they sign up to the navigators state changes and will evaluate its (i.e. the context's) <code>command</code> state. The contexts add substitution in the command evaluation that are meaningful for the particular context. Currently the following contexts are implemented:</p>
<ul>
<li><p><strong>Context2d:</strong> maps all locations on the graph that represent 2d spaces to <code>xvars</code> and <code>yvars</code> minimizing the occurrences of variable names in <code>xvars</code> and <code>yvars</code>. For example, if a navigator gets moved from node <code>A:B</code> on the edge towards the node <code>D:A</code> then <code>xvars</code> will be <code>A</code> and <code>yvars</code> will be <code>(B, D)</code>. The order of the variable names in the node names is only important if the navigator jumps to a new node or the context gets initialized. In that case the node gets split into the two variables and the first gets mapped onto <code>xvars</code> and the second to <code>yvars</code>. After initialization the context2d will try to keep the variables in the same <code>xvars</code> or <code>yvars</code> if possible. For example, moving the navigator form not <code>A:B</code> to node <code>B:C</code> with <code>xvars=(A,C)</code> and <code>yvars=B</code>, once the navigator arrives at <code>B:C</code> then <code>xvars=C</code> and <code>yvars=B</code> even though the navigator is on <code>B:C</code>.</p></li>
<li><p><strong>Geodesic2d:</strong> every location on the graph with an orthogonal projection of the data onto a two-dimensional subspace. The nodes then represent the sub-space spanned by a pair of variates and the edges either a 3d- or 4d-transition of one scatterplot into another, depending on how many variates the two nodes connected by the edge share. The <code>geodesic2d</code> context inherits from the <code>context2d</code> context.</p></li>
</ul>
<h3 id="geodesic-2d">Geodesic 2d</h3>
<p>The following code adds a geodesic2d context to a navigator:</p>
<pre><code>source iris.tcl
set G [completegraph {SepalLength SepalWidth PetalLength PetalWidth}]
set LG [linegraph {*}$G]

set g [graph {*}[interleave {-nodes -from -to -isDirected} $LG]]
set nav [$g navigator add]

set con [$g navigator use $nav context add geodesic2d\
    -data [dict filter $iris key Se* Pe*]]</code></pre>
<p>This will open a new scatterplot showing the projection defined by the navigator location. Opening a new scatterplot is the default behaviour. Every navigator position change will evaluate the command in the <code>command</code> state of the context. The default command state is</p>
<pre><code>$g navigator use $nav context use $con cget -command

#% .l2.plot configure -x %x -y %y -xlabel %xlabel -ylabel %ylabel</code></pre>
<p>where <code>.l2.plot</code> is the widget path name of the newly created scatterplot. If the <code>command</code> state is specified at context creation time, no scatterplot will be created. The <code>command</code> state supports substitutions similar to bindings. The substitution table is</p>
<table>
<thead>
<tr class="header">
<th align="center">string</th>
<th align="left">substituted value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>%W</code></td>
<td align="left">widget path name (i.e. the graph)</td>
</tr>
<tr class="even">
<td align="center"><code>%nav</code></td>
<td align="left">navigator id</td>
</tr>
<tr class="odd">
<td align="center"><code>%con</code></td>
<td align="left">context id</td>
</tr>
<tr class="even">
<td align="center"><code>%x</code></td>
<td align="left">x coordinates of projection</td>
</tr>
<tr class="odd">
<td align="center"><code>%y</code></td>
<td align="left">y coordinates of projection</td>
</tr>
<tr class="even">
<td align="center"><code>%xlabel</code></td>
<td align="left">suitable x label for projection</td>
</tr>
<tr class="odd">
<td align="center"><code>%ylabel</code></td>
<td align="left">suitable y label for projection</td>
</tr>
<tr class="even">
<td align="center"><code>%from</code></td>
<td align="left">from state of navigator</td>
</tr>
<tr class="odd">
<td align="center"><code>%to</code></td>
<td align="left">to state of navigator</td>
</tr>
<tr class="even">
<td align="center"><code>%p</code></td>
<td align="left">proportion state of navigator</td>
</tr>
</tbody>
</table>
<p>The context2d has a couple of noteworthy states, use the <code>info states</code> approach to learn more about them:</p>
<pre><code>set statesInfo [$g use navigator $nav context use $con info states]

dict keys $statesInfo

dict get $statesInfo scaling</code></pre>
<h3 id="context-2d">Context 2d</h3>
<p>The context2d substitutions are</p>
<table>
<thead>
<tr class="header">
<th align="center">string</th>
<th align="left">substituted value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>%W</code></td>
<td align="left">widget path name (i.e. the graph)</td>
</tr>
<tr class="even">
<td align="center"><code>%nav</code></td>
<td align="left">navigator id</td>
</tr>
<tr class="odd">
<td align="center"><code>%con</code></td>
<td align="left">context id</td>
</tr>
<tr class="even">
<td align="center"><code>%xvars</code></td>
<td align="left">x variables</td>
</tr>
<tr class="odd">
<td align="center"><code>%yvars</code></td>
<td align="left">y variables</td>
</tr>
<tr class="even">
<td align="center"><code>%from</code></td>
<td align="left">from state of navigator</td>
</tr>
<tr class="odd">
<td align="center"><code>%to</code></td>
<td align="left">to state of navigator</td>
</tr>
<tr class="even">
<td align="center"><code>%p</code></td>
<td align="left">proportion state of navigator</td>
</tr>
</tbody>
</table>
<p>If the context2d description <a
href="learn_Tcl_display_graph.html#contexts">above</a> wasn't clear enough use the following code to get a sense of how <code>xvars</code> and <code>yvars</code> change.</p>
<pre><code>set G [completegraph {A B C D E F G}]
set LG [linegraph {*}$G &quot;-&quot;]

set g [graph {*}[interleave {-nodes -from -to -isDirected} $LG]]

set nav [$g navigator add]

set con [$g navigator use $nav context add context2d\
    -command {puts &quot;%xvars to %yvars: [format %.3f %p]&quot;} -separator &quot;-&quot;]</code></pre>
<ul>
<li>Note that the default separator is <code>:</code> but it can be changed to any string in the <code>linegraph</code> function and as a context2d state.</li>
</ul>
<p>The graph can be switched as follows</p>
<pre><code>set LGnot [complement {*}$LG]

$g configure {*}[interleave {-nodes -from -to -isDirected} $LGnot]</code></pre>
<ul>
<li>Note that the navigator jumps to the first node in the graph if the graph changes.</li>
</ul>
<h2 id="graph-switch-widget">Graph Switch Widget</h2>
<p>Sometimes it is useful to easily switch between different graphs. The graph selector widget maintains a list of graphs and updates the <code>activewidget</code> if a graph in its list gets selected.</p>
<p>For this example we pack a graph selector next to a graph display. More on widget layouts can be read <a
href="learn__layout.html">here</a>.</p>
<pre><code>set tt [toplevel .example]
wm title .example &quot;Loon graph example with a graph switch&quot;

set g [graph .example.graph]

set gs [graphswitch .example.graphswitch -activewidget $g]

pack $g -side left -fill both -expand TRUE
pack $gs -side left -fill y</code></pre>
<div class="figure">
<img src="images/display_graphswitch_empty.png" title="loon graph and graphswitch" alt="" />

</div>
<p>A graph gets added to the graph switch as follows</p>
<pre><code>set G1 [completegraph {A B C D}]
set G2 [list {a b c} {a a} {b c} FALSE]
set G3 [linegraph {*}$G1]
set G4 [complement {*}$G2]

set idG1 [$gs add $G1 &quot;G1&quot;] 
set idG2 [$gs add $G2 &quot;G2&quot;]
set idG3 [$gs add $G3 &quot;G3=linegraph(G1)&quot;]
set idG4 [$gs add $G4 &quot;complement(G3)&quot;]

$gs set $idG3</code></pre>
<div class="figure">
<img src="images/display_graphswitch_selected.png" title="loon graph and graphswitch" alt="" />

</div>
<ul>
<li>To switch a graph select it in the list. Layout, selection, and active states are not stored in the graph switch, only the graph information.</li>
</ul>
<h3 id="working-with-the-graphswitch">Working with the Graphswitch</h3>
<p>The API of the graph switch is similar to that of the layers, except that graphs are arranged in a flat list and layers are arranged in a tree structure.</p>
<p>For the graphswitch widget graphs are defined by a list with node names and a list with <code>from</code> node names and a list with <code>to</code> node names to define the edges, and a logical value whether the edges are directed or not.</p>
<pre><code>set gs [graphswitch]

set graphId [$gs add &lt;graph&gt; &lt;label&gt; &lt;index&gt;]</code></pre>
<p>where <code>index</code> is the position in the list. The arguments for <code>&lt;label&gt;</code> and <code>&lt;index&gt;</code> are optional.</p>
<p>The <code>add</code> method returns an id for the added graph.</p>
<p>Currently the <code>activewidget</code> state of <code>gs</code> is not set to any graph widget. Selecting a graph will throw an error saying that the graphswitch has not activewidget set. To set an activewidget (i.e. a graph widget) use</p>
<pre><code>set g [graph]

$gs configure -activewidget $g</code></pre>
<p>Now, to push a graph in <code>gs</code> to the graph widget <code>g</code> you can either mouse select a graph on the graphswitch widget, or do it programmatically as follows</p>
<pre><code>$gs set $graphId</code></pre>
<p>We continue by adding a few more graphs in order to introduce the other graphswitch related functions.</p>
<pre><code>$gs add {{A B C D} {A A A} {B C D} FALSE}
$gs add {{A B C D E} {A E A} {B C D} TRUE}
$gs add {{A B C} {A A} {B C} TRUE}</code></pre>
<p>To list the ids of all graph in the graphswitch use</p>
<pre><code>$gs ids</code></pre>
<p>If you have followed this example the <code>ids</code> method should return a list with ids <code>graph0</code>, <code>graph1</code>, <code>graph2</code>, and <code>graph3</code>, where the order of the ids is how they appear in the graphswitch widget. To move a graph to a different position in the list do as follows</p>
<pre><code>$gs move graph0 2</code></pre>
<p>to move <code>graph0</code> to the second last place. To reorder all graphs us</p>
<pre><code>$gs reorder {graph1 graph0 graph3 graph2}</code></pre>
<p>To get the label of a graph use</p>
<pre><code>$gs getLabel graph1</code></pre>
<p>To relabel a graph use</p>
<pre><code>$gs relabel graph1 &quot;A special graph&quot;</code></pre>
<p>To delete a graph use</p>
<pre><code>$gs delete graph2</code></pre>
<p>And to get the graph use</p>
<pre><code>$gs get graph1</code></pre>
<h1 id="graph-utilities">Graph Utilities</h1>
</body>
</html>
